<html>

<head>
    <title>suntonels</title>
</head>

<body>
    <!-- Tone.js 14.7.68 downloaded from CDN for offline work\]=[[[p]]]-->
    <script type="text/javascript" src="./Tone.js"></script>
    <!-- startaudiocontet 1.2.1 downloaded from CDN for offline work -->
    <script type="text/javascript" src="./StartAudioContext.min.js"></script>
    <script type="text/javascript" src="./tune-master/tune.js"></script>
    <script type="text/javascript" src="./PapaParse-5.0.2/papaparse.min.js"></script>
    <script type="module">
        // set up tune for alt scales
        const tune = new Tune();
        tune.loadScale("mean19");
        tune.tonicize(220);

        // alias tune.note for shorter access
        const tn = tune.note.bind(tune);

        let parsedSensorData = null;

        // parse CSV before starting to play
        Papa.parse("./sensor_data.csv", {
            download: true,
            complete: function (results) {
                console.log("loaded csv");
                parsedSensorData = results;
                StartAudioContext(Tone.context).then(play);
            }
        });


        const play = async () => {
            // map sensor data into individual arrays
            // todo: getting some values out of range-- for now just gonna Math.abs but really we want to shift the whole register above 0, problem for a less tired me
            // const accelXData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(accelX * 40));
            // const accelYData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(accelY * 15));
            // const accelZData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(accelZ * 200));
            // const magXData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(magX * 1000));
            // const magYData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(magY * 1000));
            // const magZData = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ]) => Math.abs(magZ * 100));

            // todo: try to get some kind of data structure that represents teh rate of change
            // ironic that we want rate of change in acceleration since it is a rate of change lol
            // but hoping this will help us derive some kind of more interesting rhythm
            const accelDiffs = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ], index) => {
                const nextItem = parsedSensorData.data[index + 1];
                if (typeof nextItem !== "undefined") {
                    const [, nextAccelX] = nextItem;
                    return parseFloat(nextAccelX) - parseFloat(accelX);
                }

                return 0;
            });

            const accelChordFreqMult = 20;

            const accelChords = parsedSensorData.data.map(([timestamp,accelX,accelY,accelZ,magX,magY,magZ], index) => {
                return [
                    Math.abs(accelX) * accelChordFreqMult,
                    Math.abs(accelY) * accelChordFreqMult,
                    Math.abs(accelZ) * accelChordFreqMult
                ];
            });


            // looks like [0, 0.15, -0.3, 0, 0.3, -0.15, 0, 0, -0.15, 0, 0.15, ...]

            const keys = new Tone.PolySynth(Tone.Synth, {
                volume: -8,
                oscillator: {
                    partials: [1, 2, 1],
                },
            }).toDestination();

            const cChord = ["C4", "E4", "G4", "B4"];
            const dChord = ["D4", "F4", "A4", "C5"];
            const gChord = ["B3", "D4", "E4", "A4"];


            const accelDiffsSummed = accelDiffs.reduce((accumulator, value, index) => {
                // todo: this could be written more nicely but w/e
                if (index === 0) return accumulator;
                if (index === 1) return [...accumulator, Math.abs(value)];

                return [...accumulator, accumulator[accumulator.length-1] + Math.abs(value)]; 
            }, []);

            // const justFirstDiffs = accelDiffsSummed.slice(0, 120);
            const accelDiffsChords = accelDiffsSummed.map((diff, index) => [diff, accelChords[index]]);
            const diffPianoPart = new Tone.Part(((time, chord) => {
                keys.triggerAttackRelease(chord, "8n", time);
            }), accelDiffsChords).start(0);


            diffPianoPart.loop = true;
            diffPianoPart.loopEnd = "1m";
            diffPianoPart.humanize = true;


            Tone.Transport.bpm.value = 90;

            // the loops start when the Transport is started
            Tone.Transport.start();
        };

    </script>
</body>

</html>